%{
	#include "hw3_output.hpp"
	#include <iostream>
	#include <stdlib.h>
    #include "utils.hpp"
	using namespace std;

	extern int yylex();
    extern int yylineno;
	int yyerror(const char * message);
    #define YYDEBUG 1
%}

%token tkvoid
%token tkint
%token tkbyte
%token tkbool
%token tkb


%token tktrue
%token tkfalse
%token tkreturn

%token tkbreak
%token tkcontinue
%token tksc
%token tkcomma

%token tklbrace
%token tkrbrace
%token tkif
%token tkwhile

%token<token> tkid
%token<token> tknumber
%token<token> tksrting

%left tkassign
%left tkor
%left tkand
%left tkequality
%nonassoc tkorder
%left tkarithmetic
%left tkproduct
%right tknot
%left tklp
%left tkrp
%nonassoc then
%nonassoc tkelse

%type<exp> Exp
%type<exp> Type
%type<expList> ExpList
%type<exp> RetType
%type<expList> FormalsList
%type<exp> Call
%%

Program	:{init();}	Funcs
        {endScope();}
	;

Funcs	:   /* empty */ {}
    | FuncDecl Funcs {}
	;
FuncDecl :  RetType tkid {insertToScope($2->lexeme,$1->type,true);createScope(true);} tklp Formals tkrp {addArguments($2->lexeme);} tklbrace Statements tkrbrace {endScope();}

RetType:   Type {$$=$1;}
         | tkvoid{$$=new Expression();$$->type="VOID";};
Formals:   /* empty */ {}
	|	FormalsList {}
	;
FormalsList:   FormalDecl {} 
    |   FormalDecl tkcomma FormalsList {}
    ;
FormalDecl: Type tkid {insertToScope($2->lexeme,$1->type);}
Statements: Statement {}
        |   Statements Statement{}
        ;
Exp: tklp Exp tkrp {$$=$2;}
    | Exp tkarithmetic Exp {$$=$1;}
    | Exp tkproduct Exp {$$=$1;}
    | tkid {$$=new Expression();$$->type=getType($1->lexeme);}
    | Call {$$=$1;}
    | tknumber {$$=new Expression();$$->type="INT";}  
    | tknumber tkb {$$=new Expression();$$->type="BYTE";} 
    | tksrting {$$=new Expression();$$->type="STRING";}
    | tktrue {$$=new Expression();$$->type="BOOL";} 
    | tkfalse {$$=new Expression();$$->type="BOOL";}
    | tknot Exp {$$=new Expression();$$->type="BOOL";}
    | Exp tkand Exp {$$=new Expression();$$->type="BOOL";}
    | Exp tkor Exp {$$=new Expression();$$->type="BOOL";}
    | Exp tkequality Exp {$$=new Expression();$$->type="BOOL";}
    | Exp tkorder Exp {$$=new Expression();$$->type="BOOL";}
    ;
Statement: tklbrace {createScope();} Statements tkrbrace {endScope();}
    | Type tkid tksc {insertToScope($2->lexeme,$1->type);} 
    | Type tkid tkassign Exp tksc {insertToScope($2->lexeme,$1->type);} 
    | tkid tkassign Exp tksc {} 
    | Call tksc {}
    | tkreturn tksc{}
    | tkreturn Exp tksc{}
    | tkif tklp Exp tkrp M1 Statement M2 %prec then
    | tkif tklp Exp tkrp M1 Statement  M2  tkelse M1 Statement M2 {}
    | tkwhile tklp Exp tkrp M1 Statement M2 %prec then
    | tkwhile tklp Exp tkrp M1 Statement M2 tkelse M1 Statement M2
    | tkbreak tksc{}
    | tkcontinue tksc{}
    ;
M1: {createScope();};
M2: {endScope();};
Call : tkid tklp ExpList tkrp {$$=new Expression();$$->type=getType($1->lexeme);}
    | tkid tklp tkrp {$$=new Expression();$$->type=getType($1->lexeme);}
    ;
ExpList : Exp{$$=new ExpressionList();$$->types={$1->type};}
    | Exp tkcomma ExpList {
        $$=$3;
        $$->types.insert($$->types.begin(),$1->type);
    }
    ;
Type : tkint {$$=new Expression();$$->type="INT";}
    | tkbyte {$$=new Expression();$$->type="BYTE";}
    | tkbool {$$=new Expression();$$->type="BOOL";}
    ;

%%

int main()
{
    //yydebug = 1; 
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}