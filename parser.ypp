%{
	#include "hw3_output.hpp"
	#include <iostream>
	#include <stdlib.h>
    #include "utils.hpp"
	using namespace std;

	extern int yylex();
    extern int yylineno;
	int yyerror(const char * message);
    #define YYDEBUG 1
%}

%token tkvoid
%token tkint
%token tkbyte
%token tkbool
%token tkb


%token tktrue
%token tkfalse
%token tkreturn

%token tkbreak
%token tkcontinue
%token tksc
%token tkcomma

%token tklbrace
%token tkrbrace
%token tkif
%token tkwhile

%token<toke> tkid
%token<token> tknumber
%token<token> tksrting

%left tkassign
%left tkor
%left tkand
%left tkequality
%nonassoc tkorder
%left tkarithmetic
%left tkproduct
%right tknot
%left tklp
%left tkrp
%nonassoc then
%nonassoc tkelse

%type<exp> Exp
%type<exp> Type
%type<expList> ExpList
%type<exp> RetType
%type<expList> FormalsList
%type<exp> Call
%%

Program	:	Funcs
		{
		}
	;

Funcs	:   /* empty */ {}
    | FuncDecl Funcs {}
	;
FuncDecl :  RetType tkid {insertToScope($2.lexeme,$1.type);createScope(true);} tklp Formals tkrp {changeType($2.lexeme);} tklbrace Statements tkrbrace {}

RetType:   Type {$$=$1;}
         | tkvoid{$$.type="VOID";};
Formals:   /* empty */ {}
	|	FormalsList {}
	;
FormalsList:   FormalDecl {} 
    |   FormalDecl tkcomma FormalsList {}
    ;
FormalDecl: Type tkid {insertToScope($2.lexeme,$1.type}
Statements: Statement {}
        |   Statements Statement{}
        ;
Exp: tklp Exp tkrp {$$=$2;}
    | Exp tkarithmetic Exp {$$=$1;}
    | Exp tkproduct Exp {$$=$1;}
    | tkid {$$.type=getType($1.lexeme);}
    | Call {$$=$1;}
    | tknumber {$$.type="int";}  
    | tknumber tkb {$$.type=byte;} 
    | tksrting {$$.type="STRING";}
    | tktrue {$$.type=bool;} 
    | tkfalse {$$.type=bool;}
    | tknot Exp {$$.type=bool;}
    | Exp tkand Exp {$$.type=bool;}
    | Exp tkor Exp {$$.type=bool;}
    | Exp tkequality Exp {$$.type=bool;}
    | Exp tkorder Exp {$$.type=bool;}
    ;
Statement: tklbrace {createScope();} Statements tkrbrace {endScope();}
    | Type tkid tksc {insertToScope($2.lexeme,$1.type);} 
    | Type tkid tkassign Exp tksc {insertToScope($2.lexeme,$1.type);} 
    | tkid tkassign Exp tksc {} 
    | Call tksc {}
    | tkreturn tksc{}
    | tkreturn Exp tksc{}
    | tkif tklp Exp tkrp M1 Statement M2 %prec then
    | tkif tklp Exp tkrp M1 Statement  M2  tkelse M1 Statement M2 {}
    | tkwhile tklp Exp tkrp M1 Statement M2 %prec then
    | tkwhile tklp Exp tkrp M1 Statement M2 tkelse M1 Statement M2
    | tkbreak tksc{}
    | tkcontinue tksc{}
    ;
M1: {createScope();};
M2: {endScope();};
Call : tkid tklp ExpList tkrp {$$.type=getType($1.lexeme);}
    | tkid tklp tkrp {$$.type=getType($1.lexeme);}
    ;
ExpList : Exp{$$.types={$1.type;}}
    | Exp tkcomma ExpList {
        $$.types=$3.types;
        $$.types.insert($$.types.begin(),$1.type);
    }
    ;
Type : tkint {$$.type="INT"}
    | tkbyte {$$.type="BYTE"}
    | tkbool {$$.type="BOOL"}
    ;

%%

int main()
{
    //yydebug = 1; 
    cout << "a" << endl;
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}