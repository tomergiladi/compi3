%{
	#include "hw3_output.hpp"
	#include <iostream>
	#include <stdlib.h>
    #include "utils.hpp"
	using namespace std;

	extern int yylex();
    extern int yylineno;
	int yyerror(const char * message);
    #define YYDEBUG 1
%}

%token tkvoid
%token tkint
%token tkbyte
%token tkbool
%token tkb


%token tktrue
%token tkfalse
%token tkreturn

%token tkbreak
%token tkcontinue
%token tksc
%token tkcomma

%token tklbrace
%token tkrbrace
%token tkif
%token tkwhile

%token<token> tkid
%token<token> tknumber
%token<token> tksrting

%left tkassign
%left tkor
%left tkand
%left tkequality
%nonassoc tkorder
%left tkarithmetic
%left tkproduct
%right tknot
%left tklp
%left tkrp
%nonassoc then
%nonassoc tkelse

%type<exp> Exp
%type<exp> Type
%type<expList> ExpList
%type<exp> RetType
%type<expList> FormalsList
%type<exp> Call
%%

Program	:{init();}	Funcs
        {endScope();}
	;

Funcs	:   /* empty */ {}
    | FuncDecl Funcs {}
	;
FuncDecl :  RetType tkid {
        insertToScope($2->lexeme,$1->type);createScope(true);
    } tklp Formals tkrp {
        addArguments($2->lexeme);
    } tklbrace Statements tkrbrace {
        endScope();
        delete $1;
        delete $2;
    }

RetType:   Type {$$=$1;}
         | tkvoid{$$=new Expression();$$->type="VOID";};
Formals:   /* empty */ {}
	|	FormalsList {}
	;
FormalsList:   FormalDecl {} 
    |   FormalDecl tkcomma FormalsList {}
    ;
FormalDecl: Type tkid {
          insertToScope($2->lexeme,$1->type);delete $1; delete $2;
    }
Statements: Statement {}
        |   Statements Statement{}
        ;
Exp: tklp Exp tkrp {$$=$2;}
    | Exp tkarithmetic Exp {$$=$1; delete $3;}
    | Exp tkproduct Exp {$$=$1;delete $3;}
    | tkid {$$=new Expression();$$->type=getType($1->lexeme,false); delete $1;}
    | Call {$$=$1;}
    | tknumber {$$=new Expression();$$->type="INT"; delete $1;}  
    | tknumber tkb {$$=new Expression();$$->type="BYTE"; delete $1;} 
    | tksrting {$$=new Expression();$$->type="STRING"; delete $1;}
    | tktrue {$$=new Expression();$$->type="BOOL";} 
    | tkfalse {$$=new Expression();$$->type="BOOL";}
    | tknot Exp {$$=new Expression();$$->type="BOOL";delete $2;}
    | Exp tkand Exp {$$=new Expression();$$->type="BOOL";delete $1; delete $3;}
    | Exp tkor Exp {$$=new Expression();$$->type="BOOL";delete $1; delete $3;}
    | Exp tkequality Exp {$$=new Expression();$$->type="BOOL";delete $1; delete $3;}
    | Exp tkorder Exp {$$=new Expression();$$->type="BOOL";delete $1; delete $3;}
    ;
Statement: tklbrace {createScope();} Statements tkrbrace {endScope();}
    | Type tkid tksc {insertToScope($2->lexeme,$1->type); delete $1; delete $2;} 
    | Type tkid tkassign Exp tksc {insertToScope($2->lexeme,$1->type); delete $1; delete $2; delete $4;} 
    | tkid tkassign Exp tksc {delete $1; delete $3;} 
    | Call tksc {delete $1;}
    | tkreturn tksc{}
    | tkreturn Exp tksc{delete $2;}
    | tkif tklp Exp tkrp M1 Statement M2 {delete $3;} %prec then 
    | tkif tklp Exp tkrp M1 Statement  M2  tkelse M1 Statement M2 {delete $3;}
    | tkwhile tklp Exp tkrp M1 Statement M2 {delete $3;} %prec then
    | tkwhile tklp Exp tkrp M1 Statement M2 tkelse M1 Statement M2 {delete $3;}
    | tkbreak tksc{}
    | tkcontinue tksc{}
    ;
M1: {createScope();};
M2: {endScope();};
Call : tkid tklp ExpList tkrp {$$=new Expression();$$->type=getType($1->lexeme,true); delete $1; delete $3;}
    | tkid tklp tkrp {$$=new Expression();$$->type=getType($1->lexeme,true); delete $1;}
    ;
ExpList : Exp{$$=new ExpressionList();$$->types={$1->type}; delete $1;}
    | Exp tkcomma ExpList {
        $$=$3;
        $$->types.insert($$->types.begin(),$1->type);
        delete $1;
    }
    ;
Type : tkint {$$=new Expression();$$->type="INT";}
    | tkbyte {$$=new Expression();$$->type="BYTE";}
    | tkbool {$$=new Expression();$$->type="BOOL";}
    ;

%%

int main()
{
    //yydebug = 1; 
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}